#двоичный поиск
#сложность O(log n)

import random
import math

def binary_search(arr , n , x):
    left = 0                                #левая часть массива
    right = n - 1                           # правая часть массива

    count = 0                               #счетчик операций сравнения

    while left <= right:                    #пока левая граница не превысит правую границу
        mid = (left + right) // 2           # оперделение середины 
        if x == arr[mid]:                   # если середина то что мы искали 
            count += 1                      # произошла операция сравнения
            print(f"Элемент {x} найден на позиции {mid} за {count} операций(ю)") # вывод где мы нашли элемент
            return
        elif x < arr[mid]:                  #если число меньше чем соседнее слево , то ищем в левой части 
            count += 1
            right = mid - 1
        else:                               #если число меньше чем соседнее справо , то ищем в правой части 
            count += 1
            left = mid + 1
    print(f'Число {x} не найдено, количество сравнений {count}')


# ВВод размера массива 
n = int(input("Введите размер массива: "))
# Создаем и наполняем массив случайными числами от 0 до 99
arr = [random.randint(0, n) for i in range(n)]
# Сортируем массив
arr.sort()
print(arr)
# Получаем значение для поиска от пользователя
x = int(input("Введите число для поиска: "))

# Двоичный поиск 
binary_search(arr,n ,x)

# Выводим теоретическое количество операций сравнения
theoretical_count = math.log2(n)
print(f"Теоретическое количество операций сравнения: {theoretical_count}")